/* Main.c file generated by New Project wizard
 *
 * Created:   Mar. jun. 07 2022
 * Processor: PIC18F4585
 * Compiler:  MPLAB XC8
 */

#include <xc.h>
#include <stdio.h>


//OSCILLATOR SOURCE AND DIGITAL I/O CONFIGURATION BITS
//====================================================
#pragma config	OSC = IRCIO67       //CONFIG1H (0-3) = 0010: INTIO2 oscillator, Internal oscillator block, port function on RA6 and RA7.
#pragma config	MCLRE = ON          // CONFIG3H.7 = 1: Pin de RESET habilitado y Entrada RE3 desactivado.
#pragma config	PBADEN = OFF        // CONFIG3H.1 = 0: PORTB.0 -- PORTB.4 as Digital I/O.
#pragma config	LVP = OFF           // CONFIG3H.2 = 0: Single-Supply ICSP disabled  so that PORTB.5 works as Digital I/O.

//PICIT-3 DEBUGGER SETUP CONFIGURATION BITS
//=========================================
#pragma config	WDT = OFF           // CONFIG2H (0) = 0: Watchdog Timer Disabled.

#define RS PORTAbits.  RA0
#define RW PORTAbits.  RA1
#define EN PORTAbits.  RA2
#define LCD_POWER PORTAbits. RA3

#define D0 PORTDbits.  RD0
#define D1 PORTDbits.  RD1
#define D2 PORTDbits.  RD2
#define D3 PORTDbits.  RD3
#define D4 PORTDbits.  RD4
#define D5 PORTDbits.  RD5
#define D6 PORTDbits.  RD6
#define D7 PORTDbits.  RD7

#define M_ENCODER PORTBbits. RB1
#define S_ENCODER PORTBbits. RB2
#define BUZZER PORTBbits. RB3

#define SLEEP_TIME 15
#define _XTAL_FREQ 4000000

//Constants of the system
#define mm_per_spin 42.5		
#define ms_per_cycle .1	

//State variables
float act_time = 0;			
float act_position = 0;
int cycles = 0;

float rep_low = -1;
float rep_high = -1;
int set_state = 0;

int rep_state = 0;
int rep_count = 0;
int buzzer_time = 0;

float inact_time = 0;

//State arrays
float positions_arr[10];		
float time_arr[10];		
float speed_arr[10];		

//Strings
char str_act_pos[20];
char str_act_speed[20];
char str_act_time[20];
char str_act_rep[20];

////////////////////////////////////////////////Beggining of LCD////////////////////////////////////////////////////////
void print_data(unsigned char cmd_data){
      D0 = ((cmd_data >> 0) & 1);
      D1 = ((cmd_data >> 1) & 1);
      D2 = ((cmd_data >> 2) & 1);
      D3 = ((cmd_data >> 3) & 1);
      D4 = ((cmd_data >> 4) & 1);
      D5 = ((cmd_data >> 5) & 1);
      D6 = ((cmd_data >> 6) & 1);
      D7 = ((cmd_data >> 7) & 1);
   }

// Send command to LCD
void send_cmd(unsigned char cmd){
   RS = 0;
   print_data(cmd);
   EN = 1;
   __delay_ms(1);
   EN = 0;
   __delay_ms(1);
   }

// Send data to LCD
void send_data(unsigned char data){
   RS = 1;
   print_data(data);
   EN = 1;
   __delay_ms(1);
   EN = 0;
   __delay_ms(1);
   }

// Change the line of the LCD display
void change_line(){
   send_cmd(0xC0);
   __delay_ms(1);
}

// Go to (0,0) position of the LCD display
void home(){
   send_cmd(0x02);
   __delay_ms(1);
}

// Clean the display
void clean_display(){
   send_cmd(0x01);          // Limpiar el display
   __delay_ms(3);
}

// Initialice LCD on the desired operation mode
void initialize_lcd(){
   PORTA = 0x00;                        // Initialize PORTA
   LATA = 0x00;                         // Clear PORTA
   TRISA = 0x00;                        // PORTA as Input
   PORTD = 0x00;                        // Initialize PORTD
   LATD = 0x00;                         // Clear PORTD
   TRISD= 0x00;                        // PORTADas Input

   LCD_POWER = 1;

  // 8 bits LCD initialization
  __delay_ms(50);                       // Wait 50 ms to estabilize LCD
  send_cmd(0x38);                       // 2 lines and 5x8 matrix configuration
  __delay_us(4500);                     // Wait 4.5ms
  send_cmd(0x0C);                       // Turn on display, show cursor and blink
  __delay_us(150);                      // Wait 150ms
  send_cmd(0x01);                       // Clean the display
  __delay_ms(3);                        // Wait 3ms for the cleaning to complete
  send_cmd(0x06);                       // Do not scroll the screen
}

// Convert float to string
void float_to_str(float number, char* buffer){
   sprintf(buffer, "%f", number);
}

// Write message
void write_msj (char str[]){ 
   int i = 0;
   int j = 0;
   while (1){
      send_data(str[i]);
      if (str[i] == '\0'){
	 break;
      }
      if (j == 2){
	 break;
      }
      if (j){
	 j ++;
      }
      if (str[i] == '.'){
	 j ++;
      }
      i ++;
   }
}
 
////////////////////////////////////////////////LCD end////////////////////////////////////////////////////////77

// Check if a number is between two numbers
int is_between(float x, float inf_lim, float sup_lim){
   int result = x >= inf_lim && x <= sup_lim;
   return result;
}

// Set the limits of each exercise
void set_rep_limits(void){
   if (set_state != 2){
        if (inact_time >= 2 && set_state == 0){
            rep_low = act_position;
            set_state = 1;

            BUZZER = 1;
            buzzer_time = 0;
            inact_time = 0;
        }
        else if (inact_time >= 2 && set_state == 1){
            rep_high = act_position;
            set_state = 2;

            BUZZER = 1;
            buzzer_time = 0;
            inact_time = 0;
        }
    }
}

// Check the rep state of the current exercise
void check_rep_state(void){
   if (is_between(act_position, rep_low - .1, rep_low + .1) && rep_state == 2){
      rep_state = 0;
      rep_count ++; 
      
      BUZZER = 1;
      buzzer_time = 0;
   }
   else if (is_between(act_position, rep_low - .1, rep_low + .1) && rep_state == 0){
      rep_state ++;
   }
   else if (is_between(act_position, rep_high - .1, rep_high + .1) && rep_state == 1){
      rep_state ++;
   }
}

// Actualize arrays with the current values and calculate the speed
void act_arrays(void){
    // Initialization of the first 10 cycles
    if (cycles < 10){
        positions_arr[cycles] = act_position;
        time_arr[cycles] = act_time;
        if (cycles == 0){	
        speed_arr[cycles] = (float) (positions_arr[cycles] / time_arr[cycles]);
        }
        else{			
        speed_arr[cycles] = (float) (positions_arr[cycles] - positions_arr[cycles - 1]) / (time_arr[cycles] - time_arr[cycles - 1]);
        }
        cycles += 1;
        }
    // Normal actualization
    else{
        for(int i = 0; i<9; i++){	
        positions_arr[i] = positions_arr[i + 1];
        time_arr[i] = time_arr[i + 1];
        speed_arr[i] = speed_arr[i + 1];
        }
        positions_arr[9] = act_position;
        time_arr[9] = act_time;
        speed_arr[9] = (float) (positions_arr[9] - positions_arr[8]) / (time_arr[9] - time_arr[8]);
    }
}

// Put microcontroller in sleep mode
void go_sleep(void){
    LCD_POWER = 0;
    PORTA = 0;
    PORTB = 0;
    PORTD = 0;
    Sleep();
}

// Wake up from sleep mode and initialize variables on default values
void wake_up(void){
    act_time = 0;			
    act_position = 0;

    cycles = 0;		

    inact_time = 0;	

    rep_low = -10;
    rep_high = -10;
    set_state = 0;

    rep_state = 0;
    rep_count = 0;
    buzzer_time = 0;  

    initialize_lcd();
}
   
// Check if the machine is inactive
void sleep_mode_check(void){
   if (is_between(speed_arr[9], -0.25, .25)){
      inact_time += ms_per_cycle;
   }
   else{
      inact_time = 0;
   }
   if (inact_time >= SLEEP_TIME){
      go_sleep();
   }
   set_rep_limits();
}

// Interrupt routine of the encoder
void __interrupt() int_INT0(void){
   INTCONbits.INT0IF = 0;			
   
   if (inact_time >= SLEEP_TIME){
	 wake_up();
      }
   
   if (PORTBbits.RB1){
      act_position += mm_per_spin / 12;
   }
   else if (PORTBbits.RB2){
      act_position -= mm_per_spin / 12;
   }
   
   check_rep_state();
   inact_time = 0;
   BUZZER = 0;
  }

// Timed interrupt of 100 miliseconds to actualize arrays and turn off buzzers
void __interrupt(low_priority) int_TMR0 (void){
   INTCONbits.TMR0IF  =  0;    
    
   TMR0H  = 0xFE;                    	// Last 4 bits of timer 0
   TMR0L = 0x78;                	    // First 4 bits of timer 0
   act_time += ms_per_cycle;			

   act_arrays();	
   sleep_mode_check();
   
   if (BUZZER){
      buzzer_time += ms_per_cycle;
   }
   if (buzzer_time >= .5){
      BUZZER = 0;
   }
}
  
void main(void){
    OSCCON = 0x60;		        // 4 Mhz clock
    
    PORTB = 0x00;         	    // Initialize PORTB
    LATB = 0x00;         	    // Clear PORTB 
    TRISB = 0b00000111;         // PORTB as Input
    
    PORTC= 0x00;            	// Initialize PORTC
    LATC = 0x00;              	// Clear PORTC
    TRISC= 0x00;             	// PORTC as Output
    
    PORTD= 0x00;            	// Initialize PORTD
    LATD = 0x00;              	// Clear PORTD
    TRISD= 0x00;             	// PORTD as Output

    PORTA= 0x00;            	// Initialize PORTA
    LATA = 0x00;              	// Clear PORTA
    TRISA= 0x00;             	// PORTA as Output
    
    RCONbits.IPEN=1;          	// High priority interruptions
    INTCON = 0xF0;           	// Overflow bit

    INTCON2bits.INTEDG0 = 1;    // PORTB interruption defined as rising edge
    INTCON2bits.TMR0IP = 0;     // Low priority interruption on timer
    T0CON = 0x07;           	// 16 bits  ;   Timer Mode  ; Max prescale (256)
    TMR0H = 0xFE;            	// Timer inicializtion
    TMR0L = 0x78;           	// Timer inicializtion on 100 miliseconds
    T0CONbits.TMR0ON  = 1;    	// Timer 0
    
    CVRCON = 0;                 // Comparator Voltge Reference Module OFF
    ADCON1 = 0x0F;              // All ports as DIGITAL I/O
    CMCON = 0xFF;
    
    
    go_sleep();
    LCD_POWER = 1;
    initialize_lcd();
    RW = 0;
    write_msj("Pull");

    
    while (1){

        //Write data on LCD
        clean_display();
        home();
        float_to_str(act_position, str_act_speed);
        write_msj("Pos:");
        write_msj(str_act_speed);
        
        float_to_str(rep_count, str_act_rep);
        write_msj("Rep:");
        write_msj(str_act_rep);
        
        change_line();
        write_msj("Time: ");
        float_to_str(act_time, str_act_time);
        write_msj(str_act_time);
        
        __delay_ms(100);
    }
}